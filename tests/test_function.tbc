# Test function for TBC
# Stack: ( v1 v2 ... vN e1 e2 ... eN n -- result )
# Output: 'Y' if all values match, 'N' if any mismatch
# Result: 0 if success, index i (1-based) if mismatch at position i

# Initialize constant 1
$b $a - / o!
:a:b

# test-01: values 1,2,3 vs expected 1,2,2
# 'N'
# Stack should be: 3
o@                 # 1
o@ o@ +            # 2
o@ * o@ +          # 3
o@                 # 1 (expected)
o@ o@ +            # 2
o@ *               # 2
o@ * o@ +          # 3 (n)
o@***** $t $p &    # print test name
$v &               # Call test function
$o &               # print result  
o@ $s ?
  :ttest equal 1,2,3 = 1,2,2 (N 3)  .
:s
# test-02: values 1,2,3 vs expected 1,1,3
# 'N'
# Stack should be: 2
o@                 # 1
o@ *               # 2
o@ * o@ +          # 3
o@ *               # 2 (expected)
o@                 # 1
o@ * o@ +          # 3
o@ * o@ +          # 3 (n)
o@***** $t $p &    # print test name
$v &               # Call test function via
$o &               # print result 
o@ $s ?            
  :ttest equal 1,2,3 = 2,1,3 (N 2)  .

:s
# test-03: values -1,3 -1,3
# 'N'
# Stack should be: 0
o@ o@* - t! t@        # -1
t@ o@** +             # 3
o@* o@ + t! t@ o@** - # -1
t@                    # 3
o@ *                  # 2 (n)

o@***** $t $p &    # print test name
$v &               # Call test function
$o &               # print result 
o@ $s ?            
  :ttest equal -1,3 = -1,3          .

:s
# test-04: values 1,2,3 vs expected 1,2,3
# 'Y'
# Stack should be: 0
o@                 # 1
o@ o@ +            # 2
o@ * o@ +          # 3
o@                 # 1 (expected)
o@ *               # 2
o@ * o@ +          # 3
o@ * o@ +          # 3 (n)
o@***** $t $p &    # print test name 
$v &               # Call test function
$o &               # print result 
^
  :ttest equal 1,2,3 = 1,2,3        .

# print(count, str_address)
:p                       
a! c!                    # c = count, a = str_address
$k k!                    # Sprungadressen k berechnen
o@ o@ - i!               # i = 0     
:k
    i@ a@ + @ .          # a[i] ausgeben
    i@ o@ + i!           # index erh√∂hen
    c@ i@ - k@ ?         # i < c? dann springe zu Sprungmarke k
;                        # return (print)


# Calculate 48 (ASCII '0') for output
:o  # ( N )
t! t@ t@                        #  N N       | DUP
$n ?                            #            | N>0? then jump to :n  

# N is zero, print 'Y'
    o@ ****** o@ **** + o@ *** + o@ + .  #   | print 'Y'
    o@ $z ?                              #   | jump to :z 
:n
    o@ ****** o@ **** + o@ * - .          #  | print 'N'
:z
  o@ ***** .                              #  | print blank
  o@ ***** o@ **** + w!                   #  | w=48
  w@ + .                                  #  | 0 if no error
  $c & ;                                  #  | print CR+LF and Return  

# CR+LF
:c
  o@ * * * * o@ * - o@ - .  # CR (13)
  o@ * * * o@ * + .         # LF (10)
;

# Main test function
:v
  # Stack: V1 ... Vn E1 ... En N
  # Uses only variables t, a, x, y, saves variable m  
                 # 00: V1 ... Vn E1 ... En N   
  
  # Strategy: Compare from bottom up (Vn with En first, then Vn-1 with En-1, etc.)
  m@ >           # 01: V1 ... Vn E1 En N              -- R: M | save m on R-Stack
  $m m!          # 02: V1 ... Vn E1 En N              -- R: M | store $m to m

  :m
    $r &         # 03: V1 ... Vn En ... E1 N          -- R:   | after reverse
    t! t@ t@     # 03: V1 ... Vn En En-1 ... E1 N N   -- R: M | DUP
    $p ?         # 04: V1 ... Vn En En-1 ... E1 N     -- R: M | N>0? then continue at $p
                 # 05: 0                              -- R: M | All matched (N=0)
    < m!         # 06: 0                              -- R:   | restore m            
    ;            # 07:                                -- R:   | return 0 
    
  :p  # Process pair           
    o@ -           # 07: V1 ... Vn-1 Vn En En-1 ... E1 N-1         -- R: M     | decrement N
    > $y <         # 08: V1 ... Vn-1 Vn En En-1 ... E1 Y-Addr N-1  -- R: M     | prepare for Save 
    $s &           # 09: V1 ... Vn-1 Vn En N-1                     -- R: M     | save n-1 elements to memory
    >              # 10: V1 ... Vn-1 Vn En                         -- R: M N-1 | Save N-1 on R-Stack
    t! a!          # 11: V1 ... Vn-1                               -- R: M N-1 | store En in t and Vn in a
    a@ t@ - $n ?   # 12: V1 ... Vn-1                               -- R: M N-1 | If Vn - En > 0, jump to :n
    t@ a@ - $n ?   # 13: V1 ... Vn-1                               -- R: M N-1 | If En - Vn > 0, jump to :n
  # Values matched, continue with next pair
    # Restore the N-1 elements from memory 
    $y <           # 14: V1 ... Vn-1 Y-Addr N-1              -- R: M     | prepare for Load 
    $l &           # 15: V1 ... Vn-1 E1 ... En-1 N-1                     | Load N-1 elements from memory
                   #                                                     | (reverses order)
    o@ m@ ?        # 16: V1 ... Vn-1 E1 ... En-1 N-1         -- R: M     | NEXT (jump to :m)      

  :n # not equal   # 13: V1 ... Vn-1                         -- R: M N-1
    $y <           # 14: V1 ... Vn-1 Y-Addr N-1              -- R: M     | prepare for Save   
    $s &           # 15: N-1                                 -- R: M     | drop Vs to memory 
    t! < m! t@     # 16: N-1                                 -- R:       | restore m
    o@ + ;         # 17: N                                   -- R:       | return N

# Main reverse function
# ( x1 x2 ... xn n -- xn xn-1 ... x2 x1 n )
:r
  t! $y t@        # 0-01: X1 X2 ... Xn Addr N -- R: Ra   | push Addr of $y to D-stack
  $s &            # 0-03: N                   -- R: Ra   | Store n values to memory
  t! $y t@        # 0-04: Addr N              -- R: Ra   | push Addr of $y to D-stack                                      
  $l &            # 0-05: Xn Xn-1 ... X1 N    -- R: Ra   | Load n values from memory (reversed!)
  ;

# Helper: Store n values from D-stack to memory at address
# ( X1 X2 ... Xn Addr N -- MEM: )  => ( N -- MEM: Xn Xn-1 ... X1 )
# Uses only temporary variables t and a, loop address in x
:s
  $p x!          # 0-00: X1 X2 ... Xn Addr N        -- R: Ra   | save loop address
  t! t@ t@ >     # 0-01: X1 X2 ... Xn Addr N        -- R: Ra N | DUP >R
  
  :p
    t! t@ t@     # 0-02: X1 X2 ... Xn Addr N N      -- R: Ra N | DUP
    $q           # 0-03: X1 X2 ... Xn Addr N N Q    -- R: Ra N | skip address
    ?            # 0-04: X1 X2 ... Xn Addr N        -- R: Ra N | if N>0, continue at :q
    # done
                 # 0-05: Addr 0                     -- R: Ra N | 
    t! t! < ;    # 0-06: N                          -- R:      | DROP DROP R> and Return
  
  :q             # 0-07: X1 X2 ... Xn Addr N        -- R: Ra N |
    t! a! a@     # 0-08: X1 X2 ... Xn Addr          -- R: Ra N |
    !            # 0-09: X1 X2 ... Xn-1             -- R: Ra N | store Xn at Addr
    a@ o@* +     # 0-10: X1 X2 ... Xn-1 Addr+2      -- R: Ra N |
    t@ o@ -      # 0-11: X1 X2 ... Xn-1 Addr+2 N-1  -- R: Ra N |
    o@ x@ ?      # 1-00: X1 ... Xn-1 Addr+2 N-1     -- R: Ra N | jump to P (loop)            


# Helper: Load n values from memory to D-stack
# ( Addr N -- MEM: Xn Xn-1 ... X1 )
# Uses only temporary variables t and a, loop address in x
:l
  $p x!          # 0-00: Addr N                     -- R: Ra   | save loop address
  t! t@ t@ >     # 0-01: Addr N                     -- R: Ra N | DUP >R
  :p
    t! t@ t@     # 0-02: Addr N N                   -- R: Ra N | DUP
    $q           # 0-03: Addr N N Q                 -- R: Ra N | skip address
    ?            # 0-04: Addr N                     -- R: Ra N | if N>0, continue at :q
    # done
                 # 0-05: Xn Xn-1 ... X1 Addr 0      -- R: Ra N | 
    t! t! < ;    # 0-06: Xn Xn-1 ... X1 N           -- R: Ra   | DROP DROP R>
                 #                                             | store N back on D-Stack
  :q             # 0-07: Addr N                     -- R: Ra N |
    t! a! a@     # 0-08: Addr                       -- R: Ra N |
    @            # 0-09: Xn                         -- R: Ra N | fetch Xn from Addr
    a@ o@* +     # 0-10: Xn Addr+2                  -- R: Ra N |
    t@ o@ -      # 0-11: Xn Addr+2 N-1              -- R: Ra N |
    o@ x@        # 0-12: Xn Addr+2 N-1 1 P          -- R: Ra N |
    ?            # 1-00: Xn Addr+2 N-1              -- R: Ra N | jump to P (loop)

# Reserve memory buffer (30 slots should be enough)
:y============================================================