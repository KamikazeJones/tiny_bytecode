# Reverse function for TBC
# Stack: ( x1 x2 ... xn n -- xn xn-1 ... x2 x1 n )
# Reverses n values on stack, keeps n on top
# Uses R-stack as temporary storage

# Initialize constant 1
$b $a - / o!
:a:b

# Calculate 48 (ASCII '0') = 32 + 16 = 2^5 + 2^4
o@ * * * * * o@ * * * * +  # 48
w!  # Store in w for later use

# Test: reverse 1 2 3 with n=3
# Expected result: 3 2 1 (without n)
o@            # 1
o@ o@ +       # 2
o@ o@ + o@ +  # 3
t! t@ t@ t@ + # 6
o@ o@ + o@ + o@ +  # 4 (n)

$u &  # Call u - push to R-stack
# On r-stack should be: ( 6 3 2 1)

# Print results (should be '1236')
# Add 48 to each value before printing
# Sollte ausgeben: 1 2 3 6
<<<<
w@ + . w@ + . w@ + . w@ + .

# CR (13)
o@ * * * * o@ * - o@ - .

# LF (10)
o@ * * * o@ * + .

o@ o@ +  # 2
o@       # 1
$u &
< w@ + .
^

# Helper: Push n values from D-stack to R-stack
# ( x1 x2 ... xn n -- ) | R: ( -- xn ... x2 x1 )
# Uses only temporary variable t, x and a
:u
  $x x!                      # 0:    V1 V2 V3 V4 N          -- R: Addr
  :x
    t! t@ t@                 # 0-01: V1 V2 V3 V4 N N        -- R: Addr      | dup
    $s                       # 0-02: V1 V2 V3 V4 N N S      -- R: Addr      | skip address
    ?                        # 0-03: V1 V2 V3 V4 N          -- R: Addr      | (N>0? dann weiter bei skip)
    # fertig
    t! ;                     # 0-04:                        -- R:           | DROP and return
  :s
                             # 0-05: V1 V2 V3 V4 N          -- R: Addr      |
    t! a! <                  # 0-06: V1 V2 V3 Addr          -- R:           |
    a@ > >                   # 0-07: V1 V2 V3               -- R: V4 Addr   |
    t@ o@ -                  # 0-08: V1 V2 V3 N-1           -- R: V4 Addr   |       
    o@ x@                    # 0-09: V1 V2 V3 N-1 1 X       -- R: V4 Addr   |
    ?                        # 1-01: V1 V2 V3 N-1           -- R: V4 Addr   | jump to X (loop)

# Helper: Pull n values from R-stack to D-stack
# ( n -- x1 x2 ... xn ) | R: ( xn ... x2 x1 -- )
# Uses only temporary variable t, a and x
:v
  $x x!                      # 0:    N                      -- R: Xn ... X2 X1 Addr
  :x
    t! t@ t@                 # 0-01: N N                    -- R: Xn ... X2 X1 Addr | dup
    $s                       # 0-02: N N S                  -- R: Xn ... X2 X1 Addr | skip address
    ?                        # 0-03: N                      -- R: Xn ... X2 X1 Addr | (N>0? continue at :s)
    # fertig
    t! ;                     # 0-04:                        -- R:                   | DROP and return

  :s                         # 0-05: N                      -- R: Xn ... X2 X1 Addr |
    t! < a! < a@ >           # 0-06: X1                     -- R: Xn ... X2 Addr    |
    t@ o@ -                  # 0-07: X1 N-1                 -- R: Xn ... X2 Addr    |
    o@ x@                    # 0-08: X1 N-1 1 X             -- R: Xn ... X2 Addr    |
    ?                        # 1-01: X1 N-1                 -- R: Xn ... X2 Addr    | jump to X (loop)

# Helper: Rotate top element to position n
# ( x1 ... xn-1 xn n -- xn x1 ... xn-1 )
# Uses only temporary variable t and y
  
:w             # 0:    X1 ... Xn-1 Xn N       -- R: Addr               |
  @k >         # 0-01: X1 ... Xn-1 Xn N       -- R: Addr K             | save k on R-stack 
  k! y!        # 0-02: X1 ... Xn-1            -- R: Addr K             | k=N, y=Xn
  k@ o@ - k!   # 0-03: X1 ... Xn-1 N-1        -- R: Addr K             | k=k-1
  $u &         # 0-04:                        -- R: Addr K Xn-1 ... X1 | push N-1 values
  y@ k@        # 0-05: Xn N-1                 -- R: Addr K Xn-1 ... X1 | (Xn on D-stack, rest on R-stack)
  $v &         # 0-05: Xn X1 X2 ... Xn-1      -- R: Addr K             | pull N-1 values back
  < k!         # 0-06: Xn X1 ... Xn-1         -- R: Addr               | restore k
  ;

# Main reverse function
# ( x1 x2 ... xn n -- xn xn-1 ... x2 x1 )
# Uses only temporary variable t and a
:r
  $g                         # 0:    X1 X2 ... Xn N         -- R: Addr
  :g
    t! t@ t@                 # 0-01: X1 X2 ... Xn N N       -- R: Addr      | dup
    $h                       # 0-02: X1 X2 ... Xn N N G     -- R: Addr      | continue address
    ?                        # 0-03: X1 X2 ... Xn N N G S   -- R: Addr      | (N>0? continue)
    # fertig
    t! ;                     # 0-04: X1 X2 ... Xn N         -- R: Addr      | DROP and return
                             # 0-05: Xn ... X2 X1           -- R:           |
  :h
                             # 0-06: X1 X2 ... Xn N G       -- R: Addr      |
    >                        # 0-07: X1 X2 ... Xn N         -- R: Addr G    |
    t! t@ t@                 # 0-08: X1 X2 ... Xn N N       -- R: Addr G    | dup
    $w &                     # 0-09: X1 X2 ... Xn N         -- R: Addr G    | rotate
                             # 0-10: Xn X1 X2 ... Xn-1      -- R: Addr G    |
    o@ -                     # 0-11: Xn X1 X2 ... Xn-1 N-1  -- R: Addr G    |
    <                        # 0-12: Xn X1 X2 ... Xn-1 N-1 G -- R: Addr    |
    t! t@ t@                 # 0-13: Xn X1 ... Xn-1 N-1 G G -- R: Addr      | dup
    o@                       # 0-14: Xn X1 ... Xn-1 N-1 G G 1 -- R: Addr    |
    t! a! t@ a@              # 0-15: Xn X1 ... Xn-1 N-1 G 1 G -- R: Addr    | swap
    ?                        # 1-01: Xn X1 ... Xn-1 N-1 G   -- R: Addr      | jump to G (loop)

#################################################################
# Variante mit nur zwei Variablen
#
# Helper: Push n values from D-stack to R-stack
# ( x1 x2 ... xn n -- ) | R: ( -- xn ... x2 x1 )
# Uses only temporary variable t and a
:u
  $l                         # 0:    V1 V2 V3 V4 N          -- R: Addr
  :l
    t! a! a@ t@ a@           # 0-01: V1 V2 V3 V4 N L        -- R: Addr      | over  
    $s                       # 0-02: V1 V2 V3 V4 N L N      -- R: Addr      | skip address
    ?                        # 0-03: V1 V2 V3 V4 N L N S    -- R: Addr      | (N>0? dann weiter bei skip)
    # fertig
    t! t! ;                  # 0-04: N L                    -- R: Addr      | DROP DROP and return
                             # 0-05:                        -- R:           | 
  :s
                             # 0-06: V1 V2 V3 V4 N L        -- R: Addr      |
    >                        # 0-07: V1 V2 V3 V4 N          -- R: Addr L    |
    t! a! t@ a@              # 0-08: V1 V2 V3 N V4          -- R: Addr L    | swap
    <                        # 0-09: V1 V2 V3 N V4 L        -- R: Addr      |
    t! a! t@ a@              # 0-10: V1 V2 V3 N L V4        -- R: Addr      | swap
    <                        # 0-11: V1 V2 V3 N L V4 Addr   -- R:           |
    t! a! t@ a@              # 0-12: V1 V2 V3 N L Addr V4   -- R:           | swap
    >                        # 0-13: V1 V2 V3 N L Addr      -- R: V4        |
    >                        # 0-14: V1 V2 V3 N L           -- R: V4 Addr   |
    >                        # 0-15: V1 V2 V3 N             -- R: V4 Addr L |
    o@ -                     # 0-16: V1 V2 V3 N-1           -- R: V4 Addr L |
    <                        # 0-17: V1 V2 V3 N-1 L         -- R: V4 Addr   |
    t! t@ t@                 # 0-18: V1 V2 V3 N-1 L L       -- R: V4 Addr   | dup
    o@                       # 0-19: V1 V2 V3 N-1 L L 1     -- R: V4 Addr   |
    t! a! t@ a@              # 0-20: V1 V2 V3 N-1 L 1 L     -- R: V4 Addr   | swap
    ?                        # 1-01: V1 V2 V3 N-1 L         -- R: V4 Addr   | jump to L (loop)

